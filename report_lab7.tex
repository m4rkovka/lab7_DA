\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{ulem}
\usepackage[russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\thispagestyle{empty}
\begin{center}
    {\Large Московский авиационный институт\\ (национальный исследовательский университет)}

    \vspace{48pt}

    {\large Факультет информационных технологий и прикладной математики}

    \vspace{36pt}

    {\large Кафедра вычислительной математики и~программирования}

    \vspace{48pt}
    
    Лабораторная работа \textnumero 7 по курсу \enquote{Дискретный анализ}

\end{center}
    
    \vspace{72pt}
    
    \begin{flushright}
    \begin{tabular}{rl}
    Студент: & А.\,Н. Марков \\
    Преподаватель: & Н.\,А. Зацепин \\
    Группа: & М8О-308Б \\
    Дата: & \\
    Оценка: & \\
    Подпись: & \\
    \end{tabular}
    \end{flushright}
    
    \vfill
    
    \begin{center}
    \bfseries
    Москва, \the\year
\end{center}

\newpage

\subsection*{Условие}
\begin{enumerate}
\item Общая постановка задачи 

При помощи метода динамического программирования разработать алгоритм решения задачи, определяемой своим вариантом; оценить время выполнения алгоритма и объем затрачиваемой оперативной памяти. Перед выполнением задания необходимо обосновать применимость метода динамического программирования.

Разработать программу на языке C или C++, реализующую построенный алгоритм. Формат входных и выходных данных описан в варианте задания:

\item Вариант задания 

Вариант 6. Задана строка S состоящая из n прописных букв латинского алфавита. Вычеркиванием из этой строки некоторых символов можно получить другую строку, которая будет являться палиндромом. Требуется найти количество способов вычеркивания из данного слова некоторого (возможно, пустого) набора таких символов, что полученная в результате строка будет являться палиндромом. Способы, отличающиееся только порядком вычеркивания символов, считаются одинаковыми.

\item Формат входных данных

Задана одна строка S $(|S| \leq 100)$.

\item Формат результата

Необходимо вывести одно число – ответ на задачу. Гарантируется, что он $\leq 2^{63} - 1$.

\end{enumerate}

\subsection*{Метод решения}

Динамическое программирование позволяет решать задачи, комбинируя решения вспомогательных задач. Таким образом, для решения задачи нужно решить подзадачи, и из результатов подзадач сформировать результат задачи. Подзадачи могут быть одинаковы. В алгоритме динамического программирования каждая подзадача решается только один раз, после чего ответ сохраняется в таблице. Это позволяет избежать одних и тех же повторных вычислений каждый раз, когда встречается данная, уже ранее решенная, подзадача. 

Моя задача эквивалентна задаче поиска количества уникальных палиндромных подпоследовательностей, поскольку каждой уникальной палиндромной подпоследовательности можно поставить в соответствие набор индексов символов, вычеркивающихся из строки. Такая задача идеально подходит для решения алгоритмом динамического программирования, поскольку она прекрасно разбивается на подзадачи, решения которых перекрываются. 

Введем двумерный массив $D$: $D[i][j]$ - количество палиндромных подпоследовательной в строке, начинающейся с символа, имеющего индекс $i$, и заканчивающаяся в символе, имеющем индекс $j$.

\begin{itemize}
    \item Если $i = j$, то строка состоит из одного символа, а значит является палиндромом.
    
    \item Если $S[i] \neq S[j]$, то количество палиндромов в строке $S[i..j]$ равно количеству палиндромов в строке $S[i + 1..j]$ плюс количество палиндромов в $S[i..j - 1]$ минус количество палиндромов в $S[i + 1..j - 1]$. Вычитание здесь необходимо, поскольку при сложении количеств палиндромов в $S[i + 1..j]$ и $S[i..j - 1]$ дважды будут учитываться палиндромы из строки $S[i + 1..j - 1]$. 
    
    \item Если $S[i] = S[j]$, то ситуация такая же как и в случае $S[i] \neq S[j]$, но нужно учитывать, что строка, состоящая только из символов $S[i]$ и $S[j]$, тоже является палиндромом, а также добавятся палиндромы вида $A\$A$, где $A = S[i] = S[j]$, а \$ - палиндром из $S[i + 1..j - 1]$, таких палиндромов будет столько же, сколько и палиндромов в $S[i + 1..j - 1]$.
\end{itemize}

Таким образом, можно сформировать рекуррентное соотношение:

$$\left\{
  \begin{array}{cc}
     1, i = j \\
     0, i > j \\
     1 + D[i + 1][j] + D[i][j - 1] , S[i] = S[j] \\
     D[i + 1][j] + D[i][j - 1] - D[i + 1][j - 1], S[i] \neq S[j] \\
  \end{array}
\right.$$

\subsection*{Описание программы}

Программа состоит из одного файла main.cpp, в котором находится восходящая реализация алгоритма и функция main.
\subsection*{Дневник отладки}

Программа зашла на чекер с первой попытки.

\newpage

\subsection*{Тест производительности}

Тесты создавались с помощью небольших программы generator.py. Создавались строки с n-ым количеством символов.

\begin{tikzpicture}
	\begin{axis}[ylabel=Время в мкс,xlabel=Количество символов в строке, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
	    ( 10000, 1161043 )
	    ( 7500, 607603 )
	    ( 5000, 273167 )
	    ( 2500, 69848 )
	    ( 1000, 12132 )
	    ( 500, 4958 )
		( 100, 580 )};
	\end{axis}

\end{tikzpicture}

\subsection*{Выводы}

Динамическое программирование полезно, когда задача, разбивается на более простые подзадачи, которые могут перекрываться. Решив такие подзадачи, можно сформировать ответ на первоначальную задачу.

В данной лабораторной работе было сложнее понять, как решать поставленную задачу, нежели реализовать ее программно.

\end{document}